% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metric.values.MI.R
\name{metric.values.MI}
\alias{metric.values.MI}
\title{Calculate metric values}
\usage{
metric.values.MI(
  fun.DF,
  fun.Community,
  fun.MetricNames = NULL,
  boo.Adjust = FALSE,
  fun.cols2keep = NULL,
  boo.marine = FALSE,
  boo.Shiny = FALSE
)
}
\arguments{
\item{fun.DF}{Data frame of taxa (list required fields)}

\item{fun.Community}{Community name for which to calculate metric values (bugs, fish, or algae)}

\item{fun.MetricNames}{Optional vector of metric names to be returned.
If none are supplied then all will be returned.  Default=NULL}

\item{boo.Adjust}{Optional boolean value on whether to perform adjustments of
values prior to scoring.  Default = FALSE but may be TRUE for certain metrics.}

\item{fun.cols2keep}{Column names of fun.DF to retain in the output.  Uses column names.}

\item{boo.marine}{Should estuary/marine metrics be included.
Ignored if fun.MetricNames is not null. Default = FALSE.}

\item{boo.Shiny}{Boolean value for if the function is accessed via Shiny.  Default = FALSE.}
}
\value{
data frame of SampleID and metric values
}
\description{
This function calculates metric values for bugs and fish.
Inputs are a data frame with SampleID and taxa with phylogenetic and autecological information
(see below for required fields by community).  The dplyr package is used to generate the metric values.
}
\details{
All percent metric results are 0-100.

No manipulations of the taxa are performed by this routine.
All benthic macroinvertebrate taxa should be identified to the appropriate
operational taxonomic unit (OTU).

Any non-count taxa should be identified in the "Exclude" field as "TRUE".
These taxa will be excluded from taxa richness metrics (but will count for
all others).  #' Any non-target taxa should be identified in the "NonTarget"
field as "TRUE".  Non-target taxa are those that are not part of your intended
capture list; e.g., fish,  herps, water column taxa, or water surface taxa in
a benthic sample.  The target list will vary by program.  The non-target taxa
will be removed prior to any calculations.

Excluded taxa are ambiguous taxa (on a sample basis), i.e.,
the parent taxa when child taxa are present.  For example, the parent taxa
Chironomidae would be excluded when the child taxa Tanytarsini is present.
Both would be excluded when Tanytarsus is present.  The markExcluded function
can be used to populated this field.

There are a number of required fields (see below) for metric to calculation.
If any fields are missing the user will be prompted as to which are missing
and if the user wants to continue or quit.  If the user continues the missing
fields will be added but will be filled with zero or NA (as appropriate).
Any metrics based on the missing fields will not be valid.

A future update may turn these fields into function parameters.  This would
allow the user to tweak the function inputs to match their data rather than
having to update their data to match the function.

Required Fields:

* SAMPLEID (character or number, must be unique)

* TAXAID (character or number, must be unique)

* N_TAXA

* EXCLUDE (valid values are TRUE and FALSE)

* INDEX_NAME

* INDEX_REGION (BCG or MMI site category; e.g., for BCG PacNW valid values are "hi" or "lo")

* NONTARGET (valid values are TRUE and FALSE)

* PHYLUM, SUBPHYLUM, CLASS, SUBCLASS, INFRAORDER, ORDER, FAMILY, SUBFAMILY, TRIBE, GENUS

* FFG, HABIT, LIFE_CYCLE, TOLVAL, BCG_ATTR, THERMAL_INDICATOR, FFG2, TOLVAL2,
LONGLIVED, NOTEWORTHY, HABITAT

Valid values for FFG: CG, CF, PR, SC, SH

Valid values for HABIT: BU, CB, CN, SP, SW

Valid values for LIFE_CYCLE: UNI, SEMI, MULTI

Valid values for THERMAL_INDICATOR: COLD, COLD_COOL, COOL_WARM, WARM

Valid values for LONGLIVED: TRUE, FALSE

Valid values for NOTEWORTHY: TRUE, FALSE

Valid values for HABITAT: BRAC, DEPO, GENE, HEAD, RHEO, RIVE, SPEC, UNKN

Columns to keep are additional fields in the input file that the user wants
retained in the output.  Fields need to be those that are unique per sample
and not associated with the taxa.  For example, the fields used in qc.check();
Area_mi2, SurfaceArea, Density_m2, and Density_ft2.

If fun.MetricNames is provided only those metrics will be returned in the provided order.
This variable can be used to sort the metrics per the user's preferences.
By default the metric names will be returned in the groupings that were used for calculation.

The fields TOLVAL2 and FFG2 are provided to allow the user to calculate metrics
based on alternative scenarios.  For example, HBI and NCBI where the NCBI uses
a different set of tolerance values (TOLVAL2).

If TAXAID is 'NONE' and N_TAXA is "0" then metrics **will** be calculated with that record.
Other values for TAXAID with N_TAXA = 0 will be removed before calculations.

For 'Oligochete' metrics either Class or Subclass is required for calculation.

The parameter boo.Shiny can be set to TRUE when accessing this function in Shiny.
Normally the QC check for required fields is interactive.  Setting boo.Shiny to TRUE
will always continue.  The default is FALSE.
}
\examples{
# Example data (missing SubClass)

df_metric_values_bugs <- metric.values(data_benthos_PacNW, "bugs")

\dontrun{
# View Results
View(df_metric_values_bugs)
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Example 2, data from Excel

# Packages
library(readxl)
library(reshape2)

df_samps_bugs <- read_excel(system.file("extdata/Data_Benthos.xlsx"
                                       , package="BioMonTools")
                            , guess_max = 10^6)

# Columns to keep
myCols <- c("Area_mi2", "SurfaceArea", "Density_m2", "Density_ft2")

# Run Function
df_metric_values_bugs <- metric.values(df_samps_bugs, "bugs", fun.cols2keep=myCols)

\dontrun{
# View Results
View(df_metric_values_bugs)
}

# Get data in long format so can QC results more easily
df_long <- melt(df_metric_values_bugs, id.vars=c("SAMPLEID", "INDEX_NAME"
                                                 , "INDEX_REGION", toupper(myCols))
                          , variable.name="METRIC_NAME", value.name="METRIC_VALUE")

\dontrun{
# Save Results
write.table(df_long, "metric.values.tsv", col.names=TRUE, row.names=FALSE, sep="\t")

# DataExplorer Report
library(DataExplorer)
create_report(df_metric_values_bugs, "DataExplorer_Report_MetricValues.html")
create_report(df_samps_bugs, "DataExplorer_Report_BugSamples.html")
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Example 3, specific metrics or metrics in a specific order
## reuse df_samps_bugs from above

# metric names to keep (in this order)
myMetrics <- c("ni_total", "nt_EPT", "nt_Ephem", "pi_tv_intol", "pi_Ephem"
               , "nt_ffg_scrap", "pi_habit_climb")

# Run Function
df_metric_values_bugs_myMetrics <- metric.values(df_samps_bugs, "bugs"
                                                , fun.MetricNames = myMetrics)
\dontrun{
# View Results
View(df_metric_values_bugs_myMetrics)
}

}
